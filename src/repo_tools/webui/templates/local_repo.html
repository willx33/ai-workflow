{% extends "base.html" %}

{% block title %}Repo Tools - Local Repository{% endblock %}

{% block content %}
<div class="page-header">
    <h2>üì¶ Local Repository Context Copier</h2>
    <p>Copy code context from local repositories on your machine</p>
</div>

<div class="workflow-container">
    <div class="workflow-step" id="step-path-select">
        <h3>üîç Step 1: Select Path</h3>
        <div class="form-group">
            <label for="path-select">Choose a path to search for repositories:</label>
            <select id="path-select" class="select-dark"></select>
            <div class="button-group">
                <button id="scan-button" class="btn">Scan for Repositories</button>
                <button id="browse-button" class="btn btn-blue">Browse for Path</button>
                <input type="file" id="directory-input" webkitdirectory directory multiple style="display: none;" />
            </div>
        </div>
        <div id="custom-path" class="custom-path hidden">
            <p class="selected-path-label">Selected custom path:</p>
            <p id="selected-path-display" class="selected-path"></p>
        </div>
        <div id="path-loading" class="loading-indicator hidden">
            <div class="spinner"></div>
            <p>Scanning for repositories...</p>
        </div>
    </div>
    
    <div class="workflow-step hidden" id="step-repo-select">
        <h3>üìã Step 2: Select Repositories <span id="repo-selection-count" class="selection-count hidden">0</span></h3>
        <div class="form-group">
            <label>Select one or more repositories:</label>
            <div id="repo-checklist" class="repo-checklist">
                <!-- Repositories will be populated here as checkboxes -->
            </div>
            <div class="button-group">
                <button id="load-repos-button" class="btn">Load Selected Repositories</button>
                <button id="back-to-path-button" class="btn btn-secondary">Back</button>
            </div>
        </div>
        <div id="repo-loading" class="loading-indicator hidden">
            <div class="spinner"></div>
            <p>Loading repository files...</p>
        </div>
    </div>
    
    <div class="workflow-step hidden" id="step-file-summary">
        <h3>üìä Step 3: File Summary</h3>
        
        <div id="selected-repos-summary" class="summary-section hidden">
            <h4>Selected Repositories (<span id="selected-repos-count">0</span>/50):</h4>
            <div id="selected-repos-list" class="repo-list">
                <!-- Selected repos will be shown here -->
            </div>
        </div>
        
        <div class="summary-box">
            <div class="summary-header">
                <h4>Files to be included:</h4>
                <span id="included-count" class="count-badge">0 files</span>
            </div>
            
            <!-- File Tree Search -->
            <div class="tree-search">
                <span class="tree-search-icon">üîç</span>
                <input type="text" id="tree-search-input" class="tree-search-input" placeholder="Search files...">
                <button id="tree-search-clear" class="tree-search-clear">√ó</button>
            </div>
            
            <!-- New File Tree View -->
            <div id="file-tree" class="file-tree">
                <!-- File tree will be rendered here -->
                <div class="tree-empty">
                    <div class="tree-empty-icon">üìÇ</div>
                    <p>No files loaded yet</p>
                </div>
            </div>
            
            <div class="summary-header">
                <h4>Files ignored:</h4>
                <span id="ignored-count" class="count-badge">0 files</span>
            </div>
        </div>
        
        <div class="action-buttons">
            <button id="copy-button" class="btn btn-primary">üìã Copy to Clipboard</button>
            <button id="refresh-button" class="btn btn-info">üîÑ Refresh Files</button>
            <button id="back-to-select-button" class="btn btn-secondary">Back</button>
        </div>
    </div>
</div>

<!-- File Preview Modal -->
<div id="file-preview-modal" class="file-preview-modal">
    <div class="file-preview-content">
        <div class="file-preview-header">
            <div class="file-preview-title">
                <span class="file-preview-title-icon">üìÑ</span>
                <span id="file-preview-filename">filename.ext</span>
            </div>
            <button id="file-preview-close" class="file-preview-close">√ó</button>
        </div>
        <div class="file-preview-body">
            <pre id="file-preview-code" class="file-preview-code"></pre>
        </div>
    </div>
</div>

<div id="notification" class="notification hidden">
    <div class="notification-content">
        <span id="notification-message"></span>
        <span class="notification-close">&times;</span>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize socket.io
        const socket = io();
        
        // DOM elements
        const stepPathSelect = document.getElementById('step-path-select');
        const pathSelect = document.getElementById('path-select');
        const scanButton = document.getElementById('scan-button');
        const browseButton = document.getElementById('browse-button');
        const directoryInput = document.getElementById('directory-input');
        const customPath = document.getElementById('custom-path');
        const selectedPathDisplay = document.getElementById('selected-path-display');
        const pathLoading = document.getElementById('path-loading');
        
        const stepRepoSelect = document.getElementById('step-repo-select');
        const repoChecklist = document.getElementById('repo-checklist');
        const repoSelectionCount = document.getElementById('repo-selection-count');
        const loadReposButton = document.getElementById('load-repos-button');
        const backToPathButton = document.getElementById('back-to-path-button');
        const repoLoading = document.getElementById('repo-loading');
        
        const stepFileSummary = document.getElementById('step-file-summary');
        const includedCount = document.getElementById('included-count');
        const fileTree = document.getElementById('file-tree');
        const ignoredCount = document.getElementById('ignored-count');
        const copyButton = document.getElementById('copy-button');
        const refreshButton = document.getElementById('refresh-button');
        const backToSelectButton = document.getElementById('back-to-select-button');
        const selectedReposSummary = document.getElementById('selected-repos-summary');
        const selectedReposCount = document.getElementById('selected-repos-count');
        const selectedReposList = document.getElementById('selected-repos-list');
        
        // File tree search
        const treeSearchInput = document.getElementById('tree-search-input');
        const treeSearchClear = document.getElementById('tree-search-clear');
        
        // File preview modal
        const filePreviewModal = document.getElementById('file-preview-modal');
        const filePreviewFilename = document.getElementById('file-preview-filename');
        const filePreviewCode = document.getElementById('file-preview-code');
        const filePreviewClose = document.getElementById('file-preview-close');
        
        const notification = document.getElementById('notification');
        const notificationMessage = document.getElementById('notification-message');
        const notificationClose = document.querySelector('.notification-close');
        
        // Repository data
        let availableRepos = [];
        let selectedRepoIds = []; // Store selected repo IDs
        let selectedRepos = [];
        let fileTreeData = []; // Store hierarchical file tree data
        let totalTokenCount = 0; // Track total tokens across all repos
        
        // Load paths
        function loadPaths() {
            axios.get('/api/paths')
                .then(response => {
                    pathSelect.innerHTML = '';
                    response.data.paths.forEach(path => {
                        const option = document.createElement('option');
                        option.value = path.path;
                        option.textContent = path.display;
                        
                        // Set selected if this is the default path (parent directory)
                        if (response.data.default && path.path === response.data.default) {
                            option.selected = true;
                        }
                        
                        pathSelect.appendChild(option);
                    });
                })
                .catch(error => {
                    showNotification('Error loading paths: ' + error.message, 'error');
                });
        }
        
        // Scan for repositories
        function scanRepositories() {
            // First check if we have a custom path displayed
            let path;
            if (!customPath.classList.contains('hidden')) {
                // Use the custom path from the file browser
                path = selectedPathDisplay.textContent.trim();
            } else {
                // Use the path from the dropdown
                path = pathSelect.value;
            }
            
            if (!path) {
                showNotification('Please select a valid path', 'error');
                return;
            }
            
            pathLoading.classList.remove('hidden');
            
            socket.emit('scan_repos', { path: path });
        }
        
        // Handle directory selection via browser's file dialog
        function handleDirectorySelection(e) {
            if (e.target.files.length > 0) {
                // Get the root directory path
                const rootPath = e.target.files[0].webkitRelativePath.split('/')[0];
                
                // Extract the full path in a cross-platform way
                // This is a limitation of the browser API - we can only get the selected directory name,
                // not its full path due to security restrictions
                // We'll display the selected directory name and pass it to the backend
                
                // Display the selected directory
                selectedPathDisplay.textContent = rootPath;
                customPath.classList.remove('hidden');
                
                // Simulate full path for display (this would need backend functionality)
                // In a real implementation, you would need to resolve this path on the server side
                showNotification(`Selected directory: ${rootPath}`, 'info');
            }
        }

        // Update selection count badge
        function updateSelectionCount() {
            const count = selectedRepoIds.length;
            repoSelectionCount.textContent = count;
            
            if (count > 0) {
                repoSelectionCount.classList.remove('hidden');
            } else {
                repoSelectionCount.classList.add('hidden');
            }
        }
        
        // Load selected repositories
        function loadSelectedRepositories() {
            if (selectedRepoIds.length === 0) {
                showNotification('Please select at least one repository', 'warning');
                return;
            }
            
            // Disable Step 2
            stepRepoSelect.classList.add('disabled');
            
            // Show loading indicator
            repoLoading.classList.remove('hidden');
            
            // Keep track of loaded repositories
            let loadedCount = 0;
            selectedRepos = [];
            fileTreeData = [];
            
            // Load each selected repository
            selectedRepoIds.forEach((repoId, index) => {
                const repo = availableRepos.find(r => r.id === repoId);
                if (!repo) return;
                
                setTimeout(() => {
                    axios.post('/api/repo-files', { repoPath: repo.path })
                        .then(response => {
                            // Create repository object with data
                            const loadedRepo = {
                                name: repo.name,
                                path: repo.path,
                                included: response.data.included,
                                ignored: response.data.ignored
                            };
                            
                            // Add to selected repos
                            selectedRepos.push(loadedRepo);
                            
                            // Convert the repository's files into a hierarchical tree structure
                            const repoTreeData = buildFileTree(loadedRepo.included, loadedRepo.name);
                            fileTreeData.push(repoTreeData);
                            
                            // Track completion
                            loadedCount++;
                            
                            // If all repos are loaded
                            if (loadedCount === selectedRepoIds.length) {
                                repoLoading.classList.add('hidden');
                                
                                // Update UI with file summary
                                updateFileSummary();
                                
                                // Render the file tree
                                renderFileTree();
                                
                                // Show the file summary step
                                stepFileSummary.classList.remove('hidden');
                                
                                // Save initial selection state to localStorage
                                saveSelectionState();
                            }
                        })
                        .catch(error => {
                            loadedCount++;
                            showNotification(`Error loading repository ${repo.name}: ${error.message}`, 'error');
                            
                            // If all repos are loaded
                            if (loadedCount === selectedRepoIds.length) {
                                repoLoading.classList.add('hidden');
                                
                                if (selectedRepos.length > 0) {
                                    // We have at least some repos, so continue
                                    updateFileSummary();
                                    renderFileTree();
                                    stepFileSummary.classList.remove('hidden');
                                } else {
                                    // Re-enable Step 2 if no repos were loaded
                                    stepRepoSelect.classList.remove('disabled');
                                }
                            }
                        });
                }, index * 200); // Stagger requests
            });
        }
        
        // Go back to Step 1
        function backToPathSelection() {
            // Hide Step 2
            stepRepoSelect.classList.add('hidden');
            
            // Re-enable Step 1
            stepPathSelect.classList.remove('disabled');
            
            // Clear previous selections
            selectedRepoIds = [];
            availableRepos = [];
            repoChecklist.innerHTML = '';
            updateSelectionCount();
        }
        
        // Estimate tokens in text
        function estimateTokens(text) {
            if (!text) return 0;
            
            // Basic estimation: characters / 4 is a reasonable approximation
            // For more accuracy, we could use a proper tokenizer library
            const charCount = text.length;
            return Math.ceil(charCount / 4);
        }
        
        // Format token count with abbreviation
        function formatTokenCount(count) {
            if (count < 1000) {
                return count.toString();
            } else if (count < 1000000) {
                return (Math.round(count / 100) / 10).toFixed(1) + 'k';
            } else {
                return (Math.round(count / 100000) / 10).toFixed(1) + 'M';
            }
        }
        
        // Build a hierarchical file tree from flat file list
        function buildFileTree(files, repoName) {
            const root = { 
                name: repoName, 
                type: 'repo', 
                children: {}, 
                expanded: true,
                fileCount: files.length,
                tokenCount: 0,
                selected: true, // Default selected state
                indeterminate: false
            };
            
            files.forEach(file => {
                // Estimate tokens in file content
                const tokenCount = estimateTokens(file.content);
                
                // Extract the relative path (remove repository path prefix if present)
                let relativePath = file.path;
                if (typeof relativePath === 'string' && relativePath.includes(repoName)) {
                    // Try to extract the relative path after the repository name
                    const parts = relativePath.split(repoName);
                    if (parts.length > 1) {
                        relativePath = parts[1].replace(/^[\/\\]/, ''); // Remove leading slash
                    }
                }
                
                // Split path into segments
                const pathSegments = relativePath.split(/[\/\\]/);
                let currentLevel = root.children;
                
                // Keep track of directory paths to update token counts later
                const dirPaths = [];
                
                // Navigate through directories, creating as needed
                for (let i = 0; i < pathSegments.length - 1; i++) {
                    const segment = pathSegments[i];
                    if (!segment) continue; // Skip empty segments
                    
                    // Build the directory path for this level
                    const dirPath = pathSegments.slice(0, i + 1).join('/');
                    dirPaths.push(dirPath);
                    
                    if (!currentLevel[segment]) {
                        currentLevel[segment] = { 
                            name: segment, 
                            type: 'directory',
                            children: {},
                            expanded: false,
                            fileCount: 0,
                            tokenCount: 0,
                            path: dirPath,
                            selected: true, // Default selected state
                            indeterminate: false
                        };
                    }
                    currentLevel[segment].fileCount++;
                    currentLevel = currentLevel[segment].children;
                }
                
                // Add the file at the final level
                const fileName = pathSegments[pathSegments.length - 1];
                if (fileName) {
                    currentLevel[fileName] = { 
                        name: fileName, 
                        type: 'file',
                        path: file.path,
                        content: file.content,
                        extension: getFileExtension(fileName),
                        tokenCount: tokenCount,
                        selected: true, // Default selected state
                        indeterminate: false
                    };
                    
                    // Add to repository total token count
                    root.tokenCount += tokenCount;
                    
                    // Update token counts for all parent directories
                    for (let i = 0; i < dirPaths.length; i++) {
                        const path = dirPaths[i];
                        let dir = root.children;
                        const segments = path.split('/');
                        
                        // Navigate to the directory
                        for (let j = 0; j < segments.length; j++) {
                            const segment = segments[j];
                            if (dir[segment]) {
                                dir[segment].tokenCount += tokenCount;
                                dir = dir[segment].children;
                            }
                        }
                    }
                }
            });
            
            // After building the tree, update all selection states from bottom to top
            updateSelectionStatesBottomUp(root);
            
            return root;
        }
        
        // Get file extension
        function getFileExtension(filename) {
            return filename.slice((filename.lastIndexOf('.') - 1 >>> 0) + 2);
        }
        
        // Get file icon based on extension
        function getFileIcon(extension) {
            const iconMap = {
                // Web
                'html': 'üìÑ',
                'css': 'üìÑ',
                'js': 'üìÑ',
                'jsx': 'üìÑ',
                'ts': 'üìÑ',
                'tsx': 'üìÑ',
                
                // Config
                'json': '‚öôÔ∏è',
                'yml': '‚öôÔ∏è',
                'yaml': '‚öôÔ∏è',
                'toml': '‚öôÔ∏è',
                'env': 'üîë',
                
                // Backend
                'py': 'üêç',
                'rb': 'üíé',
                'php': 'üêò',
                'java': '‚òï',
                'go': 'üöÄ',
                'rs': 'ü¶Ä',
                'c': 'üßÆ',
                'cpp': 'üßÆ',
                'cs': 'üßÆ',
                
                // Data
                'sql': 'üóÑÔ∏è',
                'csv': 'üìä',
                'xml': 'üìä',
                
                // Documents
                'md': 'üìù',
                'mdx': 'üìù',
                'txt': 'üìù',
                
                // Default
                'default': 'üìÑ'
            };
            
            return iconMap[extension.toLowerCase()] || iconMap.default;
        }
        
        // Render file tree
        function renderFileTree() {
            // Clear previous content
            fileTree.innerHTML = '';
            totalTokenCount = 0;
            let selectedTokenCount = 0;
            let totalFileCount = 0;
            let selectedFileCount = 0;
            
            // Handle empty case
            if (fileTreeData.length === 0) {
                fileTree.innerHTML = `
                    <div class="tree-empty">
                        <div class="tree-empty-icon">üìÇ</div>
                        <p>No files loaded yet</p>
                    </div>
                `;
                return;
            }
            
            // Calculate counts first to ensure accuracy
            fileTreeData.forEach(repo => {
                totalTokenCount += repo.tokenCount;
                totalFileCount += repo.fileCount;
                
                // Count selected items
                if (repo.selected) {
                    selectedTokenCount += repo.tokenCount;
                    selectedFileCount += repo.fileCount;
                } else if (repo.indeterminate) {
                    // For indeterminate state, count only selected children
                    selectedTokenCount += getSelectedTokenCount(repo);
                    selectedFileCount += getSelectedFileCount(repo);
                }
            });

            // Now render the tree with accurate counts
            fileTreeData.forEach(repo => {
                const repoElement = document.createElement('div');
                repoElement.classList.add('tree-repo');
                repoElement.dataset.name = repo.name;
                
                // Repository header
                const repoHeader = document.createElement('div');
                repoHeader.classList.add('tree-repo-header');
                
                // Create checkbox wrapper
                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.classList.add('checkbox-wrapper');
                
                // Create checkbox for repository
                const repoCheckbox = document.createElement('input');
                repoCheckbox.type = 'checkbox';
                repoCheckbox.checked = repo.selected;
                repoCheckbox.classList.add('tree-checkbox');
                
                // Add indeterminate state if needed
                if (repo.indeterminate) {
                    repoCheckbox.classList.add('indeterminate');
                    repoCheckbox.dataset.indeterminate = 'true';
                }
                
                // Stop event propagation on the checkbox
                repoCheckbox.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                repoCheckbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    
                    // Apply selection state to repo and all its children
                    const isSelected = e.target.checked;
                    updateSelectionState(repo, isSelected);
                    
                    // Re-render tree immediately to reflect changes
                    renderFileTree();
                    
                    // Update the summary counts
                    updateFileSummary();
                    
                    // Save selection state to localStorage
                    saveSelectionState();
                });
                
                checkboxWrapper.appendChild(repoCheckbox);
                
                repoHeader.innerHTML = `
                    <div class="tree-repo-name">
                        <span class="tree-repo-icon">üì¶</span>
                        ${repo.name}
                    </div>
                    <div class="tree-repo-stats">
                        ${repo.fileCount} files ¬∑ ~${formatTokenCount(repo.tokenCount)} tokens
                    </div>
                    <div class="tree-repo-actions">
                        <button class="tree-action-button expand-all">Expand All</button>
                        <button class="tree-action-button collapse-all">Collapse All</button>
                    </div>
                `;
                
                // Insert checkbox wrapper as first child
                repoHeader.insertBefore(checkboxWrapper, repoHeader.firstChild);
                
                // Repository content
                const repoContent = document.createElement('div');
                repoContent.classList.add('tree-repo-content');
                
                // Add repository children (directories and files)
                const sortedChildren = Object.values(repo.children)
                    .sort((a, b) => {
                        // Directories first, then files
                        if (a.type !== b.type) {
                            return a.type === 'directory' ? -1 : 1;
                        }
                        // Alphabetical within same type
                        return a.name.localeCompare(b.name);
                    });
                
                sortedChildren.forEach(child => {
                    if (child.type === 'directory') {
                        repoContent.appendChild(renderDirectory(child, repo.name));
                    } else {
                        repoContent.appendChild(renderFile(child, repo.name));
                    }
                });
                
                // Keep existing event listeners for expand/collapse all
                const expandAllBtn = repoHeader.querySelector('.expand-all');
                expandAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.add('expanded');
                    });
                });
                
                const collapseAllBtn = repoHeader.querySelector('.collapse-all');
                collapseAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.remove('expanded');
                    });
                });
                
                // Toggle repository content on header click
                repoHeader.addEventListener('click', (e) => {
                    // Only toggle if not clicking on checkbox, its wrapper, or action buttons
                    if (!e.target.closest('.checkbox-wrapper') && !e.target.closest('.tree-action-button')) {
                        repoElement.classList.toggle('expanded');
                    }
                });
                
                repoElement.appendChild(repoHeader);
                repoElement.appendChild(repoContent);
                fileTree.appendChild(repoElement);
            });
            
            // Update the included count with selected token information
            includedCount.textContent = `${selectedFileCount} of ${totalFileCount} files ¬∑ ~${formatTokenCount(selectedTokenCount)} tokens`;
            
            // Apply search filter if search input has value
            applySearchFilter();
        }
        
        // Get selected file count from a node (repo or directory)
        function getSelectedFileCount(node) {
            if (node.type === 'file') {
                return node.selected ? 1 : 0;
            }
            
            if (!node.selected) {
                return 0; // If node is not selected, none of its children are counted
            }
            
            // For directories and repos, sum up selected children
            let count = 0;
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    count += getSelectedFileCount(child);
                });
            }
            return count;
        }
        
        // Update selection state recursively
        function updateSelectionState(node, isSelected) {
            // Update this node's selection state
            node.selected = isSelected;
            // Clear indeterminate state when explicitly selected/deselected
            node.indeterminate = false;
            
            // Apply to all children recursively
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    updateSelectionState(child, isSelected);
                });
            }
        }
        
        // Check if all children of a node are selected
        function areAllChildrenSelected(node) {
            if (!node.children || Object.keys(node.children).length === 0) {
                return true;
            }
            
            return Object.values(node.children).every(child => {
                return child.selected && (child.type === 'file' || areAllChildrenSelected(child));
            });
        }
        
        // Check if any children of a node are selected
        function areAnyChildrenSelected(node) {
            if (!node.children || Object.keys(node.children).length === 0) {
                return false;
            }
            
            return Object.values(node.children).some(child => {
                return child.selected || (child.type !== 'file' && areAnyChildrenSelected(child));
            });
        }
        
        // Update parent selection states based on children
        function updateParentSelectionState(parentNode) {
            if (!parentNode.children || Object.keys(parentNode.children).length === 0) {
                return;
            }
            
            const allSelected = areAllChildrenSelected(parentNode);
            const anySelected = areAnyChildrenSelected(parentNode);
            
            // Set the node's selected state based on children
            if (allSelected) {
                parentNode.selected = true;
                parentNode.indeterminate = false;
            } else if (!anySelected) {
                parentNode.selected = false;
                parentNode.indeterminate = false;
            } else {
                // Some but not all children are selected
                parentNode.selected = false;
                parentNode.indeterminate = true;
            }
            
            return { allSelected, anySelected, indeterminate: parentNode.indeterminate };
        }
        
        // Update selection states from bottom to top
        function updateSelectionStatesBottomUp(node) {
            if (!node.children || Object.keys(node.children).length === 0) {
                return;
            }
            
            // First update all children recursively
            Object.values(node.children).forEach(child => {
                if (child.type === 'directory') {
                    updateSelectionStatesBottomUp(child);
                }
            });
            
            // Then update this node based on its children
            const allSelected = areAllChildrenSelected(node);
            const anySelected = areAnyChildrenSelected(node);
            
            // Update selection state
            if (allSelected) {
                node.selected = true;
                node.indeterminate = false;
            } else if (!anySelected) {
                node.selected = false;
                node.indeterminate = false;
            } else {
                // Some but not all children are selected
                node.selected = false;
                node.indeterminate = true;
            }
        }
        
        // Render directory
        function renderDirectory(directory, repoName) {
            const dirElement = document.createElement('div');
            dirElement.classList.add('tree-directory');
            dirElement.dataset.name = directory.name;
            
            // Directory header
            const dirHeader = document.createElement('div');
            dirHeader.classList.add('tree-directory-header');
            
            // Create checkbox wrapper
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.classList.add('checkbox-wrapper');
            
            // Create checkbox for directory
            const dirCheckbox = document.createElement('input');
            dirCheckbox.type = 'checkbox';
            dirCheckbox.checked = directory.selected;
            dirCheckbox.classList.add('tree-checkbox');
            
            // Add indeterminate state if needed
            if (directory.indeterminate) {
                dirCheckbox.indeterminate = true;
                dirCheckbox.classList.add('indeterminate');
                dirCheckbox.dataset.indeterminate = 'true';
            }
            
            // Handle checkbox directly - IMPORTANT: Stop both click and change events
            dirCheckbox.addEventListener('click', (e) => {
                e.stopPropagation(); // Stop event from reaching dirHeader
            });
            
            dirCheckbox.addEventListener('change', (e) => {
                e.stopPropagation();
                
                // Get the new selection state
                const isSelected = e.target.checked;
                
                // Apply selection state to directory and ALL its children recursively
                updateSelectionState(directory, isSelected);
                
                // Track if this directory was expanded before the change
                const wasExpanded = dirElement.classList.contains('expanded');
                
                // Update the directory's visuals without replacing the whole element
                // Just update the checkbox state and any visual indicators
                dirCheckbox.checked = directory.selected;
                dirCheckbox.indeterminate = directory.indeterminate;
                
                if (directory.indeterminate) {
                    dirCheckbox.classList.add('indeterminate');
                    dirCheckbox.dataset.indeterminate = 'true';
                } else {
                    dirCheckbox.classList.remove('indeterminate');
                    dirCheckbox.dataset.indeterminate = 'false';
                }
                
                // Recursively update child checkboxes
                updateChildCheckboxes(dirElement, directory.selected);
                
                // Make sure expanded state is preserved
                if (wasExpanded) {
                    dirElement.classList.add('expanded');
                }
                
                // Update parent selection states bottom-up
                updateTreeSelectionStates();
                
                // Update the summary counts only - no need to rebuild the entire tree
                updateFileSummaryWithoutRender();
                
                // Save selection state to localStorage
                saveSelectionState();
            });
            
            checkboxWrapper.appendChild(dirCheckbox);
            
            dirHeader.innerHTML = `
                <div class="tree-directory-name">
                    <span class="tree-directory-icon">‚ñ∂</span>
                    <span>üìÇ ${directory.name}</span>
                </div>
                <div class="tree-directory-stats">
                    <span class="tree-directory-file-count">${directory.fileCount} files</span>
                    <span class="tree-directory-token-count">~${formatTokenCount(directory.tokenCount)} tokens</span>
                </div>
            `;
            
            // Insert checkbox wrapper as first child
            dirHeader.insertBefore(checkboxWrapper, dirHeader.firstChild);
            
            // Directory content
            const dirContent = document.createElement('div');
            dirContent.classList.add('tree-directory-content');
            
            // Add directory children (subdirectories and files)
            const sortedChildren = Object.values(directory.children)
                .sort((a, b) => {
                    // Directories first, then files
                    if (a.type !== b.type) {
                        return a.type === 'directory' ? -1 : 1;
                    }
                    // Alphabetical within same type
                    return a.name.localeCompare(b.name);
                });
            
            sortedChildren.forEach(child => {
                if (child.type === 'directory') {
                    dirContent.appendChild(renderDirectory(child, repoName));
                } else {
                    dirContent.appendChild(renderFile(child, repoName));
                }
            });
            
            // Toggle directory expansion on header click
            dirHeader.addEventListener('click', (e) => {
                // Only toggle if not clicking on checkbox or its wrapper
                if (!e.target.closest('.checkbox-wrapper')) {
                    e.stopPropagation();
                    dirElement.classList.toggle('expanded');
                }
            });
            
            dirElement.appendChild(dirHeader);
            dirElement.appendChild(dirContent);
            return dirElement;
        }
        
        // Update all child checkboxes in the DOM
        function updateChildCheckboxes(parentElement, isSelected) {
            const childCheckboxes = parentElement.querySelectorAll('.tree-checkbox');
            childCheckboxes.forEach(checkbox => {
                checkbox.checked = isSelected;
                checkbox.indeterminate = false;
                checkbox.classList.remove('indeterminate');
                checkbox.dataset.indeterminate = 'false';
            });
        }
        
        // Render file
        function renderFile(file, repoName) {
            const fileElement = document.createElement('div');
            fileElement.classList.add('tree-file');
            if (file.extension) {
                fileElement.classList.add(file.extension.toLowerCase());
            }
            fileElement.dataset.name = file.name;
            fileElement.dataset.path = file.path;
            fileElement.dataset.repo = repoName;
            fileElement.dataset.tokens = file.tokenCount;
            
            // File name parts
            const nameParts = file.name.split('.');
            const baseName = nameParts.length > 1 ? nameParts.slice(0, -1).join('.') : nameParts[0];
            const extension = nameParts.length > 1 ? nameParts[nameParts.length - 1] : '';
            
            // File icon
            const fileIcon = getFileIcon(file.extension || '');
            
            // Create checkbox wrapper
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.classList.add('checkbox-wrapper');
            
            // Create checkbox for file
            const fileCheckbox = document.createElement('input');
            fileCheckbox.type = 'checkbox';
            fileCheckbox.checked = file.selected;
            fileCheckbox.classList.add('tree-checkbox');
            
            // Handle checkbox directly
            fileCheckbox.addEventListener('click', (e) => {
                e.stopPropagation(); // Stop event from propagating
            });
            
            fileCheckbox.addEventListener('change', (e) => {
                e.stopPropagation();
                
                // Update this file's selection state
                file.selected = e.target.checked;
                
                // Find parent directory and update up the tree
                updateTreeSelectionStates();
                
                // Update just the checkbox appearance
                applyCheckboxState(fileCheckbox, file);
                
                // Update the summary counts
                updateFileSummaryWithoutRender();
                
                // Save selection state to localStorage
                saveSelectionState();
            });
            
            checkboxWrapper.appendChild(fileCheckbox);
            
            // Create file element structure
            const fileContent = document.createElement('div');
            fileContent.classList.add('tree-file-content');
            fileContent.innerHTML = `
                <span class="tree-file-icon">${fileIcon}</span>
                <span class="tree-file-name">${baseName}<span class="tree-file-ext">.${extension}</span></span>
                <span class="tree-file-tokens">~${formatTokenCount(file.tokenCount)}</span>
            `;
            
            // Add checkbox and file content to the element
            fileElement.appendChild(checkboxWrapper);
            fileElement.appendChild(fileContent);
            
            // File click handler
            fileContent.addEventListener('click', (e) => {
                e.stopPropagation();
                showFilePreview(file);
            });
            
            return fileElement;
        }
        
        // Get current selection state
        function getSelectionState() {
            if (!fileTreeData || fileTreeData.length === 0) return null;
            
            const state = {};
            
            fileTreeData.forEach(repo => {
                state[repo.name] = {
                    deselectedPaths: getNodeSelectionPaths(repo),
                    expansionState: getExpansionState(repo.name)
                };
            });
            
            return state;
        }
        
        // Get all paths that are NOT selected (more efficient to store deselected items)
        function getNodeSelectionPaths(node, basePath = '') {
            let paths = [];
            
            // For files, use full path to ensure unique identification
            if (node.type === 'file' && !node.selected) {
                // Use the full file path instead of just the name
                paths.push(node.path);
            } else if (node.type === 'directory' && !node.selected && !node.indeterminate) {
                // For directories, use relative path within the repo
                paths.push(basePath + (node.name || ''));
            } else if (node.children) {
                // For selected or indeterminate nodes, check children
                Object.entries(node.children).forEach(([childName, child]) => {
                    const childPath = basePath + (node.name ? node.name + '/' : '') + childName;
                    paths = paths.concat(getNodeSelectionPaths(child, childPath));
                });
            }
            
            return paths;
        }
        
        // Get current expansion state (which directories are expanded)
        function getExpansionState(repoName) {
            const expandedDirs = [];
            const repoElement = fileTree.querySelector(`.tree-repo[data-name="${repoName}"]`);
            
            if (repoElement) {
                // Get all expanded directories
                const dirs = repoElement.querySelectorAll('.tree-directory.expanded');
                dirs.forEach(dir => {
                    // Build path from repo name to this directory
                    let path = dir.dataset.name;
                    let parent = dir.parentElement.closest('.tree-directory');
                    
                    while (parent) {
                        path = parent.dataset.name + '/' + path;
                        parent = parent.parentElement.closest('.tree-directory');
                    }
                    
                    expandedDirs.push(path);
                });
            }
            
            return expandedDirs;
        }
        
        // Apply selection state saved previously
        function applySelectionState(state) {
            if (!state || !fileTreeData || fileTreeData.length === 0) return;
            
            // Apply to each repository
            fileTreeData.forEach(repo => {
                const repoState = state[repo.name];
                if (!repoState) return;
                
                // First reset all selections to true (default state)
                resetSelectionState(repo, true);
                
                // Apply deselected paths
                if (repoState.deselectedPaths) {
                    repoState.deselectedPaths.forEach(path => {
                        applySelectionPath(repo, path, false);
                    });
                }
            });
            
            // Update all parent selection states bottom-up
            fileTreeData.forEach(repo => {
                updateSelectionStatesBottomUp(repo);
            });
        }
        
        // Apply selection to a specific path
        function applySelectionPath(node, path, value) {
            // Direct match for file paths - handles both stored relative and absolute paths
            if (node.type === 'file' && (path === node.path || path === node.name)) {
                node.selected = value;
                return true;
            }
            
            // Direct match for directory names
            if ((node.type === 'directory' || node.type === 'repo') && path === node.name) {
                node.selected = value;
                if (node.children) {
                    Object.values(node.children).forEach(child => {
                        resetSelectionState(child, value);
                    });
                }
                return true;
            }
            
            // Handle nested paths for directories
            if (path.startsWith(node.name + '/') && node.children) {
                const remainingPath = path.substring(node.name.length + 1);
                const nextSegment = remainingPath.split('/')[0];
                
                if (node.children[nextSegment]) {
                    return applySelectionPath(node.children[nextSegment], remainingPath, value);
                }
            }
            
            // Handle absolute file paths match - traverse all children looking for matching path
            if (node.children && node.type !== 'file') {
                for (const child of Object.values(node.children)) {
                    if (child.type === 'file' && child.path === path) {
                        child.selected = value;
                        return true;
                    }
                    
                    // Recursively search directories
                    if (child.type !== 'file' && applySelectionPath(child, path, value)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Reset selection state of node and all children
        function resetSelectionState(node, value) {
            node.selected = value;
            node.indeterminate = false;
            
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    resetSelectionState(child, value);
                });
            }
        }
        
        // Apply expansion state
        function applyExpansionState(state) {
            if (!state || !fileTreeData || fileTreeData.length === 0) return;
            
            // Apply after the tree has been rendered
            setTimeout(() => {
                fileTreeData.forEach(repo => {
                    const repoState = state[repo.name];
                    if (!repoState || !repoState.expansionState) return;
                    
                    const repoElement = fileTree.querySelector(`.tree-repo[data-name="${repo.name}"]`);
                    if (!repoElement) return;
                    
                    // Apply each expanded directory path
                    repoState.expansionState.forEach(path => {
                        applyExpansionPath(repoElement, path);
                    });
                });
            }, 100);
        }
        
        // Apply expansion to a specific path
        function applyExpansionPath(repoElement, path) {
            const segments = path.split('/');
            let currentElement = repoElement;
            
            // Navigate through segments to find the directory
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                const dirElement = currentElement.querySelector(`.tree-directory[data-name="${segment}"]`);
                
                if (dirElement) {
                    dirElement.classList.add('expanded');
                    currentElement = dirElement;
                } else {
                    break;
                }
            }
        }
        
        // Update tree selection states bottom-up
        function updateTreeSelectionStates() {
            // Update from bottom to top
            fileTreeData.forEach(repo => {
                updateSelectionStatesBottomUp(repo);
            });
            
            // Update tree UI to reflect new states
            const checkboxes = fileTree.querySelectorAll('.tree-checkbox');
            checkboxes.forEach(checkbox => {
                const parentElement = checkbox.closest('.tree-repo, .tree-directory, .tree-file');
                
                if (parentElement) {
                    // Find matching node in data
                    let node = null;
                    
                    if (parentElement.classList.contains('tree-repo')) {
                        const repoName = parentElement.dataset.name;
                        node = fileTreeData.find(r => r.name === repoName);
                    }
                    else if (parentElement.classList.contains('tree-directory')) {
                        const dirName = parentElement.dataset.name;
                        const repoElement = parentElement.closest('.tree-repo');
                        if (repoElement) {
                            const repoName = repoElement.dataset.name;
                            const repo = fileTreeData.find(r => r.name === repoName);
                            if (repo) {
                                // Find directory by name
                                node = findNodeByName(repo, dirName);
                            }
                        }
                    }
                    else if (parentElement.classList.contains('tree-file')) {
                        const filePath = parentElement.dataset.path;
                        const repoName = parentElement.dataset.repo;
                        if (repoName) {
                            const repo = fileTreeData.find(r => r.name === repoName);
                            if (repo) {
                                // Find file by path
                                node = findNodeByPath(repo, filePath);
                            }
                        }
                    }
                    
                    // Update checkbox state to match data
                    if (node) {
                        applyCheckboxState(checkbox, node);
                    }
                }
            });
            
            // Save selection state
            saveSelectionState();
        }
        
        // Find a node by name in a tree
        function findNodeByName(root, name) {
            if (root.name === name) {
                return root;
            }
            
            if (root.children) {
                for (const child of Object.values(root.children)) {
                    const found = findNodeByName(child, name);
                    if (found) return found;
                }
            }
            
            return null;
        }
        
        // Find a node by path in a tree
        function findNodeByPath(root, path) {
            if (root.path === path) {
                return root;
            }
            
            if (root.children) {
                for (const child of Object.values(root.children)) {
                    const found = findNodeByPath(child, path);
                    if (found) return found;
                }
            }
            
            return null;
        }
        
        // Apply checkbox state based on node
        function applyCheckboxState(checkbox, node) {
            checkbox.checked = node.selected;
            
            if (node.indeterminate) {
                checkbox.indeterminate = true;
                checkbox.classList.add('indeterminate');
                checkbox.dataset.indeterminate = 'true';
            } else {
                checkbox.indeterminate = false;
                checkbox.classList.remove('indeterminate');
                checkbox.dataset.indeterminate = 'false';
            }
        }
        
        // Save selection state to localStorage
        function saveSelectionState() {
            if (!fileTreeData || fileTreeData.length === 0) return;
            
            try {
                // Get current state for each repository
                const state = {};
                
                fileTreeData.forEach(repo => {
                    state[repo.name] = {
                        deselectedPaths: getNodeSelectionPaths(repo),
                        expansionState: getExpansionState(repo.name)
                    };
                });
                
                // Save to localStorage with a key that includes the repository paths
                const repoKey = selectedRepos.map(r => r.path).sort().join(',');
                localStorage.setItem(`repo_selection_${repoKey}`, JSON.stringify(state));
            } catch (e) {
                console.error('Error saving selection state:', e);
            }
        }
        
        // Restore selection state from localStorage on page load
        function restoreSelectionState() {
            try {
                if (!selectedRepos || selectedRepos.length === 0) return;
                
                // Generate key from repository paths
                const repoKey = selectedRepos.map(r => r.path).sort().join(',');
                const savedState = localStorage.getItem(`repo_selection_${repoKey}`);
                
                if (savedState) {
                    const state = JSON.parse(savedState);
                    
                    // Convert old format to new format if needed
                    const newState = {};
                    Object.keys(state).forEach(repoName => {
                        if (Array.isArray(state[repoName])) {
                            // Old format - just deselected paths
                            newState[repoName] = {
                                deselectedPaths: state[repoName],
                                expansionState: []
                            };
                        } else {
                            // New format - already has the right structure
                            newState[repoName] = state[repoName];
                        }
                    });
                    
                    // Apply the state to the tree
                    applySelectionState(newState);
                    applyExpansionState(newState);
                    
                    // Re-render tree with updated selections
                    updateFileSummaryWithoutRender();
                }
            } catch (e) {
                console.error('Error restoring selection state:', e);
            }
        }
        
        // Update file summary without re-rendering the tree
        function updateFileSummaryWithoutRender() {
            // Calculate total files and selected files
            let totalIncludedFiles = 0;
            let totalSelectedFiles = 0;
            let totalIgnoredFiles = 0;
            totalTokenCount = 0;
            let selectedTokenCount = 0;
            
            selectedRepos.forEach(repo => {
                totalIncludedFiles += repo.included.length;
                totalIgnoredFiles += repo.ignored.length;
                
                // Find the corresponding repo in fileTreeData to get token count
                const repoData = fileTreeData.find(r => r.name === repo.name);
                if (repoData) {
                    totalTokenCount += repoData.tokenCount;
                    selectedTokenCount += getSelectedTokenCount(repoData);
                    totalSelectedFiles += getSelectedFileCount(repoData);
                }
            });
            
            // Update counts
            includedCount.textContent = `${totalSelectedFiles} of ${totalIncludedFiles} files ¬∑ ~${formatTokenCount(selectedTokenCount)} tokens`;
            ignoredCount.textContent = `${totalIgnoredFiles} files`;
            selectedReposCount.textContent = selectedRepos.length;
            
            // Update the selected repos list
            updateSelectedReposList();
        }
        
        // Show file preview
        function showFilePreview(file) {
            filePreviewFilename.textContent = `${file.name} (~${formatTokenCount(file.tokenCount)} tokens)`;
            filePreviewCode.textContent = file.content;
            filePreviewModal.classList.add('visible');
        }
        
        // Close file preview
        function closeFilePreview() {
            filePreviewModal.classList.remove('visible');
        }
        
        // Search file tree
        function searchFileTree(query) {
            if (!query) {
                // Clear search
                resetTreeSearch();
                return;
            }
            
            const lowerQuery = query.toLowerCase();
            let foundAny = false;
            
            // Search in each repo
            const repoElements = fileTree.querySelectorAll('.tree-repo');
            repoElements.forEach(repoEl => {
                let foundInRepo = false;
                
                // Search files in this repo
                const fileElements = repoEl.querySelectorAll('.tree-file');
                fileElements.forEach(fileEl => {
                    const fileName = fileEl.dataset.name.toLowerCase();
                    const filePath = fileEl.dataset.path.toLowerCase();
                    
                    if (fileName.includes(lowerQuery) || filePath.includes(lowerQuery)) {
                        fileEl.style.display = 'flex';
                        highlightMatch(fileEl, lowerQuery);
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make sure parent directories are expanded and visible
                        let parent = fileEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else {
                        fileEl.style.display = 'none';
                    }
                });
                
                // Search directories
                const dirElements = repoEl.querySelectorAll('.tree-directory');
                dirElements.forEach(dirEl => {
                    const dirName = dirEl.dataset.name.toLowerCase();
                    const hasVisibleChildren = dirEl.querySelector('.tree-file[style*="display: flex"]');
                    
                    if (dirName.includes(lowerQuery)) {
                        // Highlight the directory name and make it visible
                        const nameElement = dirEl.querySelector('.tree-directory-name span:last-child');
                        nameElement.innerHTML = nameElement.textContent.replace(
                            new RegExp(lowerQuery, 'ig'),
                            match => `<span class="match-highlight">${match}</span>`
                        );
                        
                        // Show and expand the directory
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make parent directories visible and expanded
                        let parent = dirEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else if (hasVisibleChildren) {
                        // Directory has matching files, keep it visible and expanded
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                    } else if (!hasVisibleChildren && !dirName.includes(lowerQuery)) {
                        // Hide the directory if it neither matches nor has matching children
                        dirEl.style.display = 'none';
                    }
                });
                
                // Show/hide the entire repo based on matches
                if (foundInRepo) {
                    repoEl.style.display = 'block';
                    repoEl.classList.add('expanded');
                } else {
                    repoEl.style.display = 'none';
                }
            });
            
            // Show no results message if nothing found
            if (!foundAny) {
                if (!fileTree.querySelector('.tree-empty')) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.classList.add('tree-empty');
                    emptyMessage.innerHTML = `
                        <div class="tree-empty-icon">üîç</div>
                        <p>No files match your search</p>
                    `;
                    fileTree.appendChild(emptyMessage);
                }
            } else {
                const emptyMessage = fileTree.querySelector('.tree-empty');
                if (emptyMessage) {
                    emptyMessage.remove();
                }
            }
        }
        
        // Highlight search matches
        function highlightMatch(element, query) {
            // Highlight in the file name
            const nameElement = element.querySelector('.tree-file-name');
            const originalText = nameElement.textContent;
            
            // Only replace in the text nodes to avoid messing up the extension styling
            const textNode = Array.from(nameElement.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
            const extNode = nameElement.querySelector('.tree-file-ext');
            
            if (textNode && originalText.toLowerCase().includes(query)) {
                const baseName = textNode.textContent;
                textNode.textContent = '';
                
                // Create a new span with highlighted text
                const newSpan = document.createElement('span');
                newSpan.innerHTML = baseName.replace(
                    new RegExp(query, 'ig'),
                    match => `<span class="match-highlight">${match}</span>`
                );
                
                // Insert the highlighted text before the extension
                nameElement.insertBefore(newSpan, extNode);
            }
            
            // Also check if the extension contains the query
            if (extNode && extNode.textContent.toLowerCase().includes(query)) {
                extNode.innerHTML = extNode.textContent.replace(
                    new RegExp(query, 'ig'),
                    match => `<span class="match-highlight">${match}</span>`
                );
            }
        }
        
        // Reset tree search
        function resetTreeSearch() {
            // Show all elements
            const allRepos = fileTree.querySelectorAll('.tree-repo');
            const allDirs = fileTree.querySelectorAll('.tree-directory');
            const allFiles = fileTree.querySelectorAll('.tree-file');
            
            allRepos.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allDirs.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allFiles.forEach(el => {
                el.style.display = 'flex';
                
                // Remove highlights
                const nameElement = el.querySelector('.tree-file-name');
                if (nameElement) {
                    nameElement.innerHTML = `${nameElement.textContent.split('.')[0]}<span class="tree-file-ext">.${nameElement.textContent.split('.')[1] || ''}</span>`;
                }
            });
            
            // Remove empty message if present
            const emptyMessage = fileTree.querySelector('.tree-empty');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            // Re-expand first level directories if needed
            renderFileTree();
        }
        
        // Apply current search filter
        function applySearchFilter() {
            const query = treeSearchInput.value.trim();
            if (query) {
                searchFileTree(query);
            }
        }
        
        // Update file summary UI
        function updateFileSummary() {
            // Calculate total files and selected files
            let totalIncludedFiles = 0;
            let totalSelectedFiles = 0;
            let totalIgnoredFiles = 0;
            totalTokenCount = 0;
            let selectedTokenCount = 0;
            
            selectedRepos.forEach(repo => {
                totalIncludedFiles += repo.included.length;
                totalIgnoredFiles += repo.ignored.length;
                
                // Find the corresponding repo in fileTreeData to get token count
                const repoData = fileTreeData.find(r => r.name === repo.name);
                if (repoData) {
                    totalTokenCount += repoData.tokenCount;
                    selectedTokenCount += getSelectedTokenCount(repoData);
                    totalSelectedFiles += getSelectedFileCount(repoData);
                }
            });
            
            // Update counts
            includedCount.textContent = `${totalSelectedFiles} of ${totalIncludedFiles} files ¬∑ ~${formatTokenCount(selectedTokenCount)} tokens`;
            ignoredCount.textContent = `${totalIgnoredFiles} files`;
            selectedReposCount.textContent = selectedRepos.length;
            
            // Show the selected repos section
            selectedReposSummary.classList.remove('hidden');
            
            // Update the selected repos list
            updateSelectedReposList();
        }
        
        // Get selected token count for a node (recursive)
        function getSelectedTokenCount(node) {
            if (node.type === 'file') {
                return node.selected ? node.tokenCount : 0;
            }
            
            if (!node.selected) {
                return 0; // If the node is deselected, none of its children are counted
            }
            
            // For directories and repos, sum up selected children
            let count = 0;
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    count += getSelectedTokenCount(child);
                });
            }
            return count;
        }
        
        // Get selected files from a node (recursive)
        function getSelectedFiles(node) {
            const files = [];
            
            if (node.type === 'file') {
                if (node.selected) {
                    files.push({
                        path: node.path,
                        content: node.content
                    });
                }
                return files;
            }
            
            // If this node is not selected, none of its children are included
            if (!node.selected) {
                return files;
            }
            
            // For directories and repos, collect from all children
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    files.push(...getSelectedFiles(child));
                });
            }
            
            return files;
        }
        
        // Update the list of selected repositories
        function updateSelectedReposList() {
            selectedReposList.innerHTML = '';
            
            selectedRepos.forEach(repo => {
                // Find the corresponding repo in fileTreeData to get token count
                const repoData = fileTreeData.find(r => r.name === repo.name);
                const totalTokenCount = repoData ? repoData.tokenCount : 0;
                const selectedTokenCount = repoData ? getSelectedTokenCount(repoData) : 0;
                const totalFiles = repo.included.length;
                const selectedFiles = repoData ? getSelectedFileCount(repoData) : 0;
                
                const repoItem = document.createElement('div');
                repoItem.classList.add('repo-item');
                repoItem.innerHTML = `
                    <span class="repo-name">üìÇ ${repo.name}</span>
                    <span class="repo-files">${selectedFiles} of ${totalFiles} files ¬∑ ~${formatTokenCount(selectedTokenCount)} tokens</span>
                `;
                selectedReposList.appendChild(repoItem);
            });
        }
        
        // Copy to clipboard
        function copyToClipboard() {
            if (selectedRepos.length === 0) return;
            
            // Collect all selected files from the file tree
            const selectedFilesData = [];
            fileTreeData.forEach(repo => {
                const repoFiles = getSelectedFiles(repo);
                
                if (repoFiles.length > 0) {
                    selectedFilesData.push({
                        name: repo.name,
                        path: selectedRepos.find(r => r.name === repo.name)?.path || '',
                        files: repoFiles
                    });
                }
            });
            
            // Send only selected files to be copied
            axios.post('/api/copy-to-clipboard', { selectedRepos: selectedFilesData })
                .then(response => {
                    // Calculate total selected files
                    let totalFiles = 0;
                    selectedFilesData.forEach(repo => {
                        totalFiles += repo.files.length;
                    });
                    
                    showNotification(`üìã ${totalFiles} files from ${selectedFilesData.length} repositories copied to clipboard!`, 'success');
                })
                .catch(error => {
                    showNotification('Error copying to clipboard: ' + error.message, 'error');
                });
        }
        
        // Return to repository selection
        function backToRepoSelect() {
            // Hide step 3
            stepFileSummary.classList.add('hidden');
            
            // Re-enable step 2
            stepRepoSelect.classList.remove('disabled');
            
            // Make sure step 2 is visible
            stepRepoSelect.classList.remove('hidden');
            
            // Make sure checkboxes match the currently selected repos
            updateRepoCheckboxes();
        }
        
        // Update repo checkboxes to match current selections
        function updateRepoCheckboxes() {
            // Get all checkboxes
            const checkboxes = repoChecklist.querySelectorAll('input[type="checkbox"]');
            
            // Create a set of selected paths for quick lookup
            const selectedPaths = new Set(selectedRepos.map(repo => repo.path));
            
            // Update each checkbox
            checkboxes.forEach(checkbox => {
                const repoPath = checkbox.dataset.path;
                checkbox.checked = selectedPaths.has(repoPath);
            });
            
            // Update selection count
            updateSelectionCount();
        }
        
        // Refresh repository files
        function refreshRepositoryFiles() {
            if (selectedRepos.length === 0) {
                showNotification('No repositories to refresh', 'warning');
                return;
            }
            
            showNotification('üîÑ Refreshing repository files...', 'info');
            
            // Create a loading indicator
            const loadingIndicator = document.createElement('div');
            loadingIndicator.classList.add('loading-indicator');
            loadingIndicator.innerHTML = `
                <div class="spinner"></div>
                <p>Refreshing repositories...</p>
            `;
            selectedReposSummary.appendChild(loadingIndicator);
            
            // Disable buttons during refresh
            refreshButton.disabled = true;
            copyButton.disabled = true;
            
            // First, map all file paths to their current selection state for direct comparison
            const fileSelectionMap = {};
            fileTreeData.forEach(repo => {
                collectFileSelections(repo, fileSelectionMap);
            });
            
            // Also capture expansion state
            const expandedDirs = {};
            fileTreeData.forEach(repo => {
                expandedDirs[repo.name] = getExpansionState(repo.name);
            });
            
            // Track completion for multiple repos
            let refreshedCount = 0;
            const tempSelectedRepos = [...selectedRepos];
            selectedRepos = [];
            fileTreeData = [];
            
            // Process each repository
            tempSelectedRepos.forEach((repo, index) => {
                setTimeout(() => {
                    axios.post('/api/repo-files', { repoPath: repo.path })
                        .then(response => {
                            // Create updated repo object with fresh data
                            const updatedRepo = {
                                name: repo.name,
                                path: repo.path,
                                included: response.data.included,
                                ignored: response.data.ignored
                            };
                            
                            // Add to selected repos
                            selectedRepos.push(updatedRepo);
                            
                            // Build new tree with default selections
                            const repoTreeData = buildFileTree(updatedRepo.included, updatedRepo.name);
                            
                            // Apply saved selections to the new tree
                            applyFileSelections(repoTreeData, fileSelectionMap);
                            
                            // Add to file tree data
                            fileTreeData.push(repoTreeData);
                            
                            // Update selection states from bottom to top
                            updateSelectionStatesBottomUp(repoTreeData);
                            
                            // Update progress
                            refreshedCount++;
                            
                            // If all repos are processed
                            if (refreshedCount === tempSelectedRepos.length) {
                                // Remove loading indicator
                                loadingIndicator.remove();
                                
                                // Render tree with applied selections
                                renderFileTree();
                                
                                // Then restore expanded directories
                                setTimeout(() => {
                                    fileTreeData.forEach(repo => {
                                        if (expandedDirs[repo.name] && expandedDirs[repo.name].length > 0) {
                                            const repoElement = fileTree.querySelector(`.tree-repo[data-name="${repo.name}"]`);
                                            if (repoElement) {
                                                // Expand the repo itself
                                                repoElement.classList.add('expanded');
                                                
                                                // Apply saved expansion state to each directory
                                                expandedDirs[repo.name].forEach(path => {
                                                    applyExpansionPath(repoElement, path);
                                                });
                                            }
                                        }
                                    });
                                }, 50);
                                
                                // Enable buttons
                                refreshButton.disabled = false;
                                copyButton.disabled = false;
                                
                                // Save the new selection state to localStorage
                                saveSelectionState();
                                
                                showNotification('‚úÖ All repositories refreshed successfully!', 'success');
                            }
                        })
                        .catch(error => {
                            console.error('Error refreshing repository:', error);
                            showNotification(`Error refreshing repository ${repo.name}: ${error.message}`, 'error');
                            
                            // Re-add the original repo to prevent data loss
                            selectedRepos.push(repo);
                            
                            refreshedCount++;
                            
                            // If all repos are processed
                            if (refreshedCount === tempSelectedRepos.length) {
                                loadingIndicator.remove();
                                refreshButton.disabled = false;
                                copyButton.disabled = false;
                                renderFileTree();
                            }
                        });
                }, index * 300); // Stagger requests to avoid overwhelming the server
            });
        }
        
        // Collect file selection states directly by path for accurate mapping
        function collectFileSelections(node, selectionMap) {
            if (node.type === 'file') {
                // Store the selection state by full path for files
                selectionMap[node.path] = node.selected;
            }
            
            // Recursively process children
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    collectFileSelections(child, selectionMap);
                });
            }
        }
        
        // Apply file selection states directly to the new tree
        function applyFileSelections(node, selectionMap) {
            if (node.type === 'file' && node.path in selectionMap) {
                // Apply saved selection state to this file
                node.selected = selectionMap[node.path];
            }
            
            // Recursively process children
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    applyFileSelections(child, selectionMap);
                });
            }
        }
        
        // Show notification
        function showNotification(message, type = 'info') {
            notificationMessage.textContent = message;
            notification.className = 'notification';
            notification.classList.add(`notification-${type}`);
            notification.classList.remove('hidden');
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                notification.classList.add('hidden');
            }, 3000);
        }
        
        // Socket.io events
        socket.on('scan_start', (data) => {
            // Nothing needed here, loading indicator already shown
        });
        
        socket.on('scan_complete', (data) => {
            pathLoading.classList.add('hidden');
            
            // Store available repos
            availableRepos = data.repos.map((repo, index) => ({
                id: `repo-${index}`,
                name: repo.name,
                path: repo.path
            }));
            
            // Clear previous checkboxes
            repoChecklist.innerHTML = '';
            
            // Reset selections
            selectedRepoIds = [];
            updateSelectionCount();
            
            // Populate the checklist
            availableRepos.forEach(repo => {
                const item = document.createElement('div');
                item.classList.add('repo-checkbox-item');
                item.innerHTML = `
                    <input type="checkbox" id="${repo.id}" data-path="${repo.path}" />
                    <label for="${repo.id}">üìÇ ${repo.name}</label>
                `;
                repoChecklist.appendChild(item);
                
                // Add event listener to checkbox
                const checkbox = item.querySelector('input[type="checkbox"]');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        // Add to selected repos
                        if (!selectedRepoIds.includes(repo.id)) {
                            selectedRepoIds.push(repo.id);
                        }
                    } else {
                        // Remove from selected repos
                        const index = selectedRepoIds.indexOf(repo.id);
                        if (index !== -1) {
                            selectedRepoIds.splice(index, 1);
                        }
                    }
                    updateSelectionCount();
                });
            });
            
            if (availableRepos.length > 0) {
                // Disable step 1
                stepPathSelect.classList.add('disabled');
                
                // Show step 2
                stepRepoSelect.classList.remove('hidden');
            } else {
                showNotification('No repositories found in the selected path', 'warning');
            }
        });
        
        socket.on('error', (data) => {
            pathLoading.classList.add('hidden');
            showNotification(data.message, 'error');
        });
        
        // Event listeners
        scanButton.addEventListener('click', scanRepositories);
        browseButton.addEventListener('click', () => directoryInput.click()); // Trigger the hidden file input
        directoryInput.addEventListener('change', handleDirectorySelection);
        loadReposButton.addEventListener('click', loadSelectedRepositories);
        backToPathButton.addEventListener('click', backToPathSelection);
        copyButton.addEventListener('click', copyToClipboard);
        refreshButton.addEventListener('click', refreshRepositoryFiles);
        backToSelectButton.addEventListener('click', backToRepoSelect);
        
        // File preview events
        filePreviewClose.addEventListener('click', closeFilePreview);
        filePreviewModal.addEventListener('click', (e) => {
            if (e.target === filePreviewModal) {
                closeFilePreview();
            }
        });
        
        // Search events
        treeSearchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            searchFileTree(query);
        });
        
        treeSearchClear.addEventListener('click', () => {
            treeSearchInput.value = '';
            resetTreeSearch();
        });
        
        notificationClose.addEventListener('click', () => {
            notification.classList.add('hidden');
        });
        
        // Load paths on page load
        loadPaths();
        
        // Add event listener for page load to restore selection state
        window.addEventListener('load', function() {
            // If we have selectedRepos data but no selection state in memory,
            // try to restore from localStorage
            if (selectedRepos && selectedRepos.length > 0 && fileTreeData && fileTreeData.length > 0) {
                restoreSelectionState();
            }
        });
    });
</script>
{% endblock %}